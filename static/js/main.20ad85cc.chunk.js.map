{"version":3,"sources":["peer.js","App.js","serviceWorker.js","index.js"],"names":["require","qrcode","svg2url","roles","connectionConfig","iceServers","urls","offerSide","window","location","hash","accumulateUntilPause","pauseDuration","fn","timerId","accumulate","accumulated","done","promise","Promise","resolve","reject","console","error","extracted","apply","arguments","push","clearTimeout","setTimeout","summarizeCandidates","sdpPromise","icePromise","all","then","sdp","ice","outstandingChannels","Map","outstandingIntervals","getRole","channelFrom","req","get","cancelOffer","log","clearInterval","generateOffer","role","outstandingChannelResolve","generatePromise","offerConnection","RTCPeerConnection","offerDataChannel","createDataChannel","offerPromise","createOffer","candidate","addIce","addIceComplete","o","setLocalDescription","onicecandidate","summary","offerId","parseInt","Math","random","toString","answerId","fetch","method","mode","body","JSON","stringify","posted","peerUrl","href","url","svg","interval","setInterval","response","json","length","answerSummary","parse","setRemoteDescription","forEach","addIceCandidate","RTCIceCandidate","set","outstandingChannelPromise","generateAnswer","decodeURIComponent","slice","split","offer","receivedOffer","answerConnection","ondatachannel","e","channel","answerPromise","createAnswer","answer","match","replace","channels","myPlayerId","color","BLUE","RED","NEUTRAL","BLACK","ColorLabels","Array","fill","map","x","OfferArea","props","useState","offerDetails","setOfferDetails","useEffect","PeerManager","completed","c","onChannel","className","src","offerImage","target","rel","alt","actions","REVEAL_CARD","INITIALIZE","PICK_SEED","initialGameState","turns","answerRole","GameBoard","useReducer","state","action","type","concat","seed","gameState","innerDispatch","spymaster","setSpymaster","initialSeed","colors","shuffle","pickColors","words","Words","pickBoard","w","i","word","revealed","some","t","wordStreaks","filter","reduce","streaks","minus1","minus2","externalEvents","on","off","dispatch","broadcastAction","onClick","includes","playerRole","playerId","key","App","setChannels","useRef","EventEmitter","otherPlayersCount","setOtherPlayersCount","started","setStarted","Object","values","send","current","emit","onmessage","message","data","gotChannel","onopen","count","setChannelMessage","connected","setConnected","setBroadcastAction","isLocalhost","Boolean","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","ReactDOM","render","document","getElementById","URL","process","origin","addEventListener","contentType","headers","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.20ad85cc.chunk.js","sourcesContent":["const { qrcode, svg2url } = require(\"pure-svg-code\");\n\nexport const roles = {\n  OFFER: \"OFFER\",\n  ANSWER: \"ANSWER\"\n};\n\nconst connectionConfig = {\n  iceServers: [{ urls: [\"stun:stun.l.google.com:19302\"] }]\n};\n\nconst iceGenerationTime = 200,\n  answerPollInterval = 1000;\n\nconst offerSide = !window.location.hash;\n\nconst accumulateUntilPause = (pauseDuration, fn) => {\n  let timerId;\n  let accumulate;\n  let accumulated = [];\n  let done = false;\n\n  const promise = new Promise((resolve, reject) => {\n    accumulate = function() {\n      if (done) {\n        console.error(\"Called accumulate after done accumulating\");\n        return;\n      }\n      const extracted = fn.apply(null, arguments);\n      extracted && accumulated.push(extracted);\n      timerId && clearTimeout(timerId);\n      timerId = setTimeout(() => {\n        resolve(accumulated);\n        done = true;\n      }, pauseDuration);\n    };\n  });\n\n  return { accumulate, promise };\n};\n\nconst summarizeCandidates = (sdpPromise, icePromise) =>\n  Promise.all([sdpPromise, icePromise]).then(([sdp, ice]) => ({\n    sdp,\n    ice\n  }));\n\nconst outstandingChannels = new Map();\nconst outstandingIntervals = new Map();\n\nexport default {\n  getRole() {\n    return offerSide ? roles.OFFER : roles.ANSWER;\n  },\n\n  channelFrom(req) {\n    return outstandingChannels.get(req);\n  },\n\n  cancelOffer(req) {\n    console.log(\"Cleanup\", req, outstandingIntervals)\n    if (outstandingIntervals.get(req))\n      clearInterval(outstandingIntervals.get(req));\n    return true\n  },\n\n  generateOffer(role) {\n    let generatePromise = new Promise(function(resolve, reject) {\n      const offerConnection = new RTCPeerConnection(connectionConfig);\n      const offerDataChannel = offerConnection.createDataChannel(\"c\");\n      const offerPromise = offerConnection.createOffer();\n\n      const {\n        accumulate: addIce,\n        promise: addIceComplete\n      } = accumulateUntilPause(iceGenerationTime, ice => ice.candidate);\n\n      offerPromise.then(o => {\n        offerConnection.setLocalDescription(o);\n        offerConnection.onicecandidate = addIce;\n      });\n\n      summarizeCandidates(offerPromise, addIceComplete).then(summary => {\n        const offerId = parseInt(Math.random() * 1000000000000).toString();\n        const answerId = parseInt(Math.random() * 1000000000000).toString();\n        fetch(\"https://sipcup.azurewebsites.net/api/Answer/\" + offerId, {\n          method: \"POST\",\n          mode: \"cors\",\n          body: JSON.stringify(summary)\n        }).then(posted => {\n          const peerUrl = `${window.location.href}#${offerId}:${answerId}:${role}`;\n          resolve({\n            url: peerUrl,\n            svg: svg2url(qrcode(peerUrl))\n          });\n        });\n\n        const interval = setInterval(() => {\n          fetch(\"https://sipcup.azurewebsites.net/api/Answer/\" + answerId, {\n            method: \"GET\",\n            mode: \"cors\"\n          })\n            .then(response => response.json())\n            .then(response => {\n              if (response.length > 0) {\n                const answerSummary = JSON.parse(response[0])\n                offerConnection.setRemoteDescription(answerSummary.sdp);\n                answerSummary.ice.forEach(candidate => {\n                  offerConnection.addIceCandidate(\n                    new RTCIceCandidate(candidate)\n                  );\n                });\n                clearInterval(interval);\n                outstandingChannelResolve(offerDataChannel);\n              }\n            });\n        }, answerPollInterval);\n\n        outstandingIntervals.set(generatePromise, interval);\n      });\n    });\n\n    let outstandingChannelResolve;\n    const outstandingChannelPromise = new Promise(function(resolve, reject) {\n      outstandingChannelResolve = resolve;\n    });\n    outstandingChannels.set(generatePromise, outstandingChannelPromise);\n\n    return generatePromise;\n  },\n\n  generateAnswer() {\n    const generatePromise = new Promise(function(resolve, reject) {\n\n      const [offerId, answerId, role] = decodeURIComponent(\n        window.location.hash.slice(1)\n      ).split(\":\");\n\n      fetch(\"https://sipcup.azurewebsites.net/api/Answer/\" + offerId, {\n        method: \"GET\",\n        mode: \"cors\"\n      })\n        .then(offer => offer.json())\n        .then(offer => JSON.parse(offer[0]))\n        .then(receivedOffer => {\n          const answerConnection = new RTCPeerConnection(connectionConfig);\n          answerConnection.ondatachannel = e => {\n            console.log(\"On data channel\", e);\n            outstandingChannelResolve(e.channel);\n          };\n          answerConnection.setRemoteDescription(receivedOffer.sdp).then(() => {\n            receivedOffer.ice.forEach(candidate => {\n              answerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n            });\n          });\n\n          const answerPromise = answerConnection.createAnswer();\n          answerPromise.then(answer => {\n            answerConnection.setLocalDescription(answer);\n          });\n\n          const {\n            accumulate: addIce,\n            promise: addIceComplete\n          } = accumulateUntilPause(iceGenerationTime, ice => ice.candidate);\n          answerConnection.onicecandidate = addIce;\n\n          summarizeCandidates(answerPromise, addIceComplete).then(summary => {\n            fetch(\"https://sipcup.azurewebsites.net/api/Answer/\" + answerId, {\n              method: \"POST\",\n              mode: \"cors\",\n              body: JSON.stringify(summary)\n            });\n          });\n        });\n    });\n    let outstandingChannelResolve;\n    const outstandingChannelPromise = new Promise(function(resolve, reject) {\n      outstandingChannelResolve = resolve;\n    });\n    outstandingChannels.set(generatePromise, outstandingChannelPromise);\n    return generatePromise;\n  }\n};\n","import React, { useState, useEffect, useReducer, useRef } from \"react\";\nimport { shuffle } from \"shuffle-seed\";\n\nimport PeerManager, { roles } from \"./peer.js\";\nimport \"./App.css\";\nimport { EventEmitter } from \"events\";\nimport Words from \"./words.json\";\n\nconst debug = false;\n\nif (window.location.href.match(\"http://joshuamandel.com\")) {\n  window.location.href = window.location.href.replace(\"http://\", \"https://\");\n}\n\nwindow.channels = {};\nconst myPlayerId = parseInt(Math.random() * 1000000000);\n\nconst color = { BLUE: \"BLUE\", RED: \"RED\", NEUTRAL: \"NEUTRAL\", BLACK: \"BLACK\" };\nconst ColorLabels = [\n  color.BLACK,\n  ...Array(7)\n    .fill()\n    .map(x => color.BLUE),\n  ...Array(7)\n    .fill()\n    .map(x => color.RED),\n  ...Array(9)\n    .fill()\n    .map(x => color.NEUTRAL)\n];\n\nconst pickColors = seed =>\n  shuffle(\n    ColorLabels.concat(shuffle([color.RED, color.BLUE], seed).slice(0, 1)),\n    seed\n  );\nconst pickBoard = seed => shuffle(Words, seed);\n\nfunction OfferArea(props) {\n  const [offerDetails, setOfferDetails] = useState({});\n\n  useEffect(() => {\n    const offer = PeerManager.generateOffer(props.role);\n    offer.then(({ url, svg }) => {\n      setOfferDetails({ url, svg, completed: false });\n    });\n\n    PeerManager.channelFrom(offer).then(c => {\n      setOfferDetails({ completed: true });\n      props.onChannel(props.offerId, c);\n    });\n\n    return () => {\n      console.log(\"Cleanup\", props);\n      PeerManager.cancelOffer(offer);\n    };\n  }, [props.offerId, props.role]);\n\n  if (!offerDetails.completed) {\n    return (\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={offerDetails.url}>\n        {offerDetails.url && (\n          <img src={offerDetails.svg} alt=\"\" className={props.className} />\n        )}\n      </a>\n    );\n  } else {\n    return <img className={props.className + \" done\"} src={props.offerImage} />;\n  }\n}\n\nfunction OfferApp() {\n  const [channels, setChannels] = useState({});\n  const externalEvents = useRef(new EventEmitter());\n  const [channelMessage, setChannelMessage] = useState(\"\");\n  const [otherPlayersCount, setOtherPlayersCount] = useState(0);\n  const [started, setStarted] = useState(false);\n  const seed = useRef(Math.random());\n\n  const broadcastAction = action => {\n    Object.values(channels).forEach(c => {\n      try {\n        c.send(JSON.stringify(action));\n      } catch {\n        console.log(\"Failed to send\", action, c);\n      }\n    });\n    if (action.playerId !== myPlayerId) {\n      externalEvents.current.emit(\"received\", action);\n    }\n  };\n\n  useEffect(() => {\n    Object.values(channels).forEach(\n      c =>\n        (c.onmessage = message => {\n          const action = JSON.parse(message.data);\n          broadcastAction(action);\n        })\n    );\n  }, [channels]);\n\n  const gotChannel = (offerId, c) => {\n    //TODO reuse broadcast mechanism\n    c.onopen = () =>\n      c.send(\n        JSON.stringify({\n          type: actions.PICK_SEED,\n          seed: seed.current\n        })\n      );\n\n    setChannels(channels => ({ ...channels, [offerId]: c }));\n    if (offerId > 1) {\n      setOtherPlayersCount(count => count + 1);\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      {!started && (\n        <div className=\"offer-lkk\">\n          <div className=\"player-card\">\n            <OfferArea\n              offerId={0}\n              role=\"red-team\"\n              className=\"player-icon red\"\n              offerImage=\"assets/player.004.svg\"\n              onChannel={gotChannel}\n            />\n            Red Captain\n          </div>\n          <div className=\"player-card\">\n            <OfferArea\n              offerId={1}\n              role=\"blue-team\"\n              className=\"player-icon blue\"\n              offerImage=\"assets/player.005.svg\"\n              onChannel={gotChannel}\n            />\n            Blue Captain\n          </div>\n          <div className=\"player-card\">\n            <OfferArea\n              offerId={2 + otherPlayersCount}\n              role=\"other-player\"\n              className=\"player-icon\"\n              offerImage=\"assets/player.003.svg\"\n              onChannel={gotChannel}\n            />\n            Other Players {otherPlayersCount > 0 && ` (${otherPlayersCount})`}\n          </div>\n          <div>\n            <button onClick={e => setStarted(true)}>Start Game</button>\n          </div>\n        </div>\n      )}\n      {started && (\n        <GameBoard\n          initialSeed={seed.current}\n          role={\"other-player\"}\n          broadcastAction={broadcastAction}\n          externalEvents={externalEvents.current}></GameBoard>\n      )}\n    </div>\n  );\n}\n\nconst actions = {\n  REVEAL_CARD: \"REVEAL_CARD\",\n  INITIALIZE: \"INITIALIZE\",\n  PICK_SEED: \"PICK_SEED\"\n};\nconst initialGameState = {\n  turns: []\n};\n\nconst answerRole = decodeURIComponent(window.location.hash.slice(1)).split(\n  \":\"\n)[2];\n\nfunction AnswerApp() {\n  const [channelMessage, setChannelMessage] = useState(\"\");\n  const [connected, setConnected] = useState(false);\n  const externalEvents = useRef(new EventEmitter());\n\n  const [broadcastAction, setBroadcastAction] = useState({\n    current: action => true\n  });\n\n  useEffect(() => {\n    const answer = PeerManager.generateAnswer();\n    const store = {};\n    let channel = null;\n\n    PeerManager.channelFrom(answer).then(c => {\n      setConnected(true);\n      channel = c;\n\n      c.onmessage = message => {\n        const action = JSON.parse(message.data);\n        setChannelMessage(JSON.stringify(action));\n        if (action.playerId !== myPlayerId) {\n          externalEvents.current.emit(\"received\", action);\n        }\n      };\n\n      setBroadcastAction({\n        current: action => {\n          channel.send(JSON.stringify(action));\n        }\n      });\n      window.channel = c;\n    });\n  }, []);\n\n  return (\n    <div className=\"App\">\n      {connected && (\n        <GameBoard\n          role={answerRole}\n          externalEvents={externalEvents.current}\n          broadcastAction={broadcastAction.current}></GameBoard>\n      )}\n    </div>\n  );\n}\n\nconst GameBoard = props => {\n  const [gameState, innerDispatch] = useReducer((state, action) => {\n    if (action.type === actions.INITIALIZE) {\n      return initialGameState;\n    } else if (action.type === actions.REVEAL_CARD) {\n      return {\n        ...state,\n        turns: state.turns.concat([action])\n      };\n    } else if (action.type === actions.PICK_SEED) {\n      console.log(\"Picked seed\", action)\n      return {\n        ...state,\n        seed: action.seed,\n        turns: []\n      };\n    }\n  }, initialGameState);\n\n  const [spymaster, setSpymaster] = useState(false);\n\n  const seed = gameState.seed || props.initialSeed;\n  const colors = pickColors(seed);\n  const words = pickBoard(seed)\n    .slice(0, 25)\n    .map((w, i) => ({\n      word: w,\n      revealed: gameState.turns.some(\n        t => t.type === actions.REVEAL_CARD && t.word == w\n      ),\n      color: colors[i]\n    }));\n\n  const colorOfWord = word =>\n    words.filter(w => w.word === word).map(w => w.color)[0];\n\n  const wordStreaks = gameState.turns\n    .filter(t => t.type === actions.REVEAL_CARD)\n    .map(t => ({ ...t, color: colorOfWord(t.word) }))\n    .reduce((streaks, { word, color }) => {\n      const currentStreak =\n        streaks.length > 0 ? streaks[streaks.length - 1][0].color : \"START\";\n      if (color === currentStreak) {\n        streaks[streaks.length - 1].push({ word, color });\n      } else {\n        streaks.push([{ word, color }]);\n      }\n      return streaks;\n    }, []);\n\n  const minus1 = (wordStreaks.length > 0\n    ? wordStreaks[wordStreaks.length - 1]\n    : []\n  ).map(w => w.word);\n  const minus2 = (wordStreaks.length > 1\n    ? wordStreaks[wordStreaks.length - 2]\n    : []\n  ).map(w => w.word);\n\n  console.log(colors);\n\n  useEffect(() => {\n    if (!props.externalEvents) return;\n\n    let listener = props.externalEvents.on(\"received\", innerDispatch);\n    return () => props.externalEvents.off(\"received\", innerDispatch);\n  }, [props.externalEvents]);\n\n  const dispatch = action => {\n    console.log(\"Gameboard sipatch\", action, props);\n    props.broadcastAction && props.broadcastAction(action);\n    innerDispatch(action);\n  };\n\n  return (\n    <div className=\"grid-container\">\n      <div className=\"header\">\n        <button onClick={e => dispatch({\n          type: actions.PICK_SEED,\n          seed: Math.random()\n        })}>\n        Deal New Cards\n        </button>\n        <button onClick={e => setSpymaster(!spymaster)}>\n          {spymaster ? \"Player View\" : \"Spymaster View\"}\n        </button>\n      </div>\n      {seed &&\n        words.map(({ word, revealed, color }, i) => (\n          <p\n            className={`card ${color} c${i} ${revealed ? \"revealed\" : \"hidden\"}\n            ${spymaster ? \"spymaster\" : \"non-spymaster\"}\n            ${minus1.includes(word) ? \"minus1\" : \"\"}\n            ${minus2.includes(word) ? \"minus2\" : \"\"}\n            `}\n            onClick={e =>\n              dispatch({\n                type: actions.REVEAL_CARD,\n                playerRole: props.role,\n                playerId: myPlayerId,\n                word: word\n              })\n            }\n            key={word}>\n            <span className=\"word\">{word}</span>\n          </p>\n        ))}\n      <p></p>\n      {debug && gameState.turns.map(t => <p>{JSON.stringify(t)}</p>)}\n    </div>\n  );\n};\n\nconst App = PeerManager.getRole() === roles.OFFER ? OfferApp : AnswerApp;\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}